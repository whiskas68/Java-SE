# 双亲委派机制

**类加载器**，实现类的加载动作，每个类都有自己独立的命名空间，只有自己的类加载器加载自己命名空间下的类。

类加载器的几种类型：

* 启动类加载器 -- Bootstrap Class Loader
* 扩展类加载器 -- Extension Class Loader
* 应用程序类加载器 -- Application Class Loader



启动类加载器,使用C++开发，用来加载$JAVA_HOME/lib目录中jar和tools.jar或-Xbootclasspath参数指定的类



扩展类加载器，用来加载$JAVA_HOME/lib/ext目录或使用java.ext.dir指定的类



应用程序类加载器，用来加载用户类路径下的所有类，为应用程序默认的类加载器



用户自定义类加载器，实现findclass()接口，实现自定义需求。



## 什么是双亲委派

如果一个类加载器接收到类加载请求，会首先把请求**委派**给父类加载器完成（每层的类加载器都是如此），最后所有的加载请求都传到启动类加载器来完成，如果父类加载器无法完成加载请求，则子类加载器才会尝试自己加载。

最终目的是，所有类都尽可能由顶层的父类加载器来加载，以此保证加载类的唯一性。

三大原则：

委托/委派性，体现在子类收到加载请求时，会将**委派**给父类加载器完成

可见性，体现在子类加载器可以查看父类加载器的所有类，父类加载器不能查看子类加载器的类

唯一性，避免自定义类覆盖核心类的行为，核心类只能由启动类加载器所加载。

可提供调用的方法：findClass()和loadClass()

findClass方法的重写，不会打破双亲委派模型

loadClass方法的重写，会打破双亲委派模型（适用在多版本兼容的场景--多版本web应用，SPI,service provider interface机制)



## SPI机制

由来，以JDBC的Driver接口（驱动接口）为例，Driver接口定义在jdk中，而具体实现是由各个数据库的服务商(mysql/oracle)来提供。因为DriverManager由启动类加载器加载，而实现类由服务商提供，由系统类加载器加载，此时就需要破坏双亲委派，有启动类加载器来委托子类加载器来加载Driver实现。这就是SPI机制。

SPI工作过程是基于接口编程+策略模式+配置文件组合实现动态加载。由父类提供接口，子类负责实现，父类接口通过配置文件中的实现类的全限定名(com.mysql.jdbc.Driver)确定具体的实现，并通过线程的上下文加载器接在实现类，最后执行子类的方法实现。



## 场景1，自定义类加载器，实现动态配置



## 场景2，热部署



引用：[ ] : 

[Java SPI 机制及其实现]: JavaSPI机制及其实现.html

