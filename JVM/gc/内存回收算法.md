# 内存回收算法



1. 引用计算法

   在对象中添加一个计数器，当有个地方引用它时，计数器就加1；当引用失败时，计数器就减1。

   该算法存在缺陷，很难解决两个对象互相循环引用问题。

   

2. 可达性分析算法/根搜索算法

   通过一系列的GC Roots的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径被称为引用链，如果某个对象到GC Roots间没有任何引用链相连，则证明对象不再被使用

![image-20201119193147609](C:\Users\oper\AppData\Roaming\Typora\typora-user-images\image-20201119193147609.png)

GC Roots对象包括

* 虚拟机栈（栈帧中的本地变量表）中引用的对象，比如各线程被调用的方法堆中使用到的参数，局部变量，临时变量等。
* 方法区中类静态属性引用的对象
* 方法去中常量引用的对象，比如字符串常量池（String Table）里的引用
* 本地方法栈的JNI（本地方法）引用对象
* Java虚拟机内部的引用，如基本数据类型对应的Class对象，常驻的异常对象（NullPointException，OutOfMemoryError）等，还有系统加载类
* 被同步锁（synchronized）持有的对象
* 本地代码缓存



代码演示：

```java
public class FinalizeEscapeGC {

    /**
     * 功能演示：
     *  1. 对象可以在被gc时自我拯救
     *  2. 这种自救机会只有1次，因为一个对象的finalize()方法最多只会被系统自动调用一次
     * */

    public static FinalizeEscapeGC SAVE_HOOK = null;

    public void isAlive(){
        System.out.println("yes, i am alived");
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("finalize method executed!");
        FinalizeEscapeGC.SAVE_HOOK = this;
    }

    public static void main(String[] args) throws Throwable{
        SAVE_HOOK = new FinalizeEscapeGC();

        //对象第一次成功拯救自己
        SAVE_HOOK = null;
        System.gc();

        //因为Finalizer优先级低，暂停0.5秒，来等待被执行
        Thread.sleep(500);
        if (SAVE_HOOK != null){
            SAVE_HOOK.isAlive();
        }else {
            System.out.println("no, i am dead");
        }

        SAVE_HOOK = null;
        System.gc();
        Thread.sleep(500);
        if (SAVE_HOOK != null){
            SAVE_HOOK.isAlive();
        }else {
            System.out.println("no, i am dead");
        }
    }
}
#日志输出
finalize method executed!
yes, i am alived
no, i am dead
```

结论：

在可达性分析算法中被判定为不可达对象，也不会立即被回收。需要经过两个阶段，当没有与GC Root相连接的引用链，它会被标记一次，随后进行一次筛选，条件是此对象是否有必要执行finalize()方法。如果对象在finalize方法中重新与引用链上的任何一个方法建立关联（比如把自己（this）赋值给一个对象的成员变量或类变量），则在第二次标记时它将移出“即将回收”的集合。

代码中对象的finalize方法被成功触发，并在收集前成功逃脱，但是在第二次就失败，原因是，对象的finalize方法只会被系统自动调用一次，如果对象再一次面对回收时，finalize方法就不再被触发，最终导致失败。



引用问题：强引用，软引用，弱引用，虚引用