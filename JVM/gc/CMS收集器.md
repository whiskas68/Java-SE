# CMS收集器

工作原理：

Concurrent mark sweep，使用标记-清除算法，通过并发的方式，对老年代的对象进行垃圾回收。

运作过程主要分为4个阶段，包括

* 初始标记-STW

​       标记gc roots能直接关联的对象，速度很快，需要stw。



* 并发标记

  从gc roots的直接关联对象开始遍历整个对象图，这个过程耗时较长，但是由于回收继承和业务进程是并发执行，不需要停顿业务进程。



* 重新标记-STW

  修正在并发标记阶段，因为业务进程运作而新产生未被标记的垃圾对象，停顿时间较初始标记阶段长

  

* 并发清除

​       清理掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以该阶段可以与用户线程并发执行



整个过程中，并发标记和并发清除的耗时时间长，所以这两个阶段的垃圾回收线程与用户线程并发执行。

优点：并发收集，低停顿

缺点：

1. 对处理器资源敏感。需要占用cpu计算能力（默认启动回收线程数=(cpu核数+3)/4），如果cpu为4个，回收线程数约等于1个，并发时回收线程占用25%的处理器计算资源。
2. 浮动垃圾的产生，可能出现“Con-current Mode Failure”失败而导致另外一次完全stw的Full GC。在CMS的并发标记和并发清除阶段，用户进程继续运行，并随着产生新的垃圾，这一部分垃圾对象出现在标记过程结束以后，因此CMS无法在当次清理掉
3. 内存碎片。空间碎片过多，将会给大对象分配带来麻烦。往往出现在老年代还有内存空间，但是无法找到足够大的连续内存空间来分配大对象，而不得不触发一次Full GC。为了解决这个问题，CMS通过-XX: +UseCMS-CompactAtFullCollection参数，用于在Full GC时开启碎片合并整理过程，该过程需要移动存活对象，停顿时间变长。

