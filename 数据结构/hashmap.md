# HashMap

### 集合容器有哪些

list，map，set，其中list和set实现collection接口，map为单独的接口

list为插入有序，set为无序且不允许重复值，并只允许一个null值

map为键值对结构，允许存在多个null值的entry。



jdk1.8版本的Hashmap数据结构为数组加链表，加红黑树的结构。

数组中由一个个Node组成，而通过计算每个Node节点中的key的hash值和哈希桶的长度-1进行位与运算，来获取到数组对应下标，来决定其Node的所在位置

```java
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node<K,V>[] tab; Node<K,V> p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);
```

### 关于(n - 1) & hash位与运算中，h = key.hashCode()) ^ (h >>> 16），为什么要这么设计

为了保留高位和低位的信息，减少哈希碰撞

比如

h=key.hashcode()  1111 1101 1101 1111 0101 1101 0010 1111 

^

h>>>16                     0000 0000 0000 0000 1111 1101 1101 1111

------------------------------------------------------------------------------------------

h^(h>>>16)               1111 1101 1101 1111 1010 0000 1111 0000

将高16位向右移动16位，高位补0，进行异或运算，从结果可知，保留了原高16位的信息，而低16位又参与了运算，可以看作高低二进制特征混合



### 为什么(n-1) & hash等价于取模

例如 9 % 4 = 1，9的二进制位1001，4的二进制位0100，4-1=3的二进制为0011（整数取余等价于取模） 

​        1001

&

​         0011

得到  0001，十进制为1  <[取模和2的次幂-1做异或运算的求证过程](https://www.cnblogs.com/ysocean/p/9054804.html)>

hash               1111 1101 1101 1111 1010 0000 1111 0000 

&  

16-1                 0000 0000 0000 0000 0000 0000 0000 0111

---------------------------------------------------------------------------

hash & (16-1)  0000 0000 0000 0000 0000 0000 0000 0000

